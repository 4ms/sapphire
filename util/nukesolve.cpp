/*
    nukesolve.cpp  -  Don Cross <cosinekitty@gmail.com>

    https://github.com/cosinekitty/sapphire
*/

#include <random>
#include "nucleus_engine.hpp"

static void Print(const Sapphire::NucleusEngine& engine);
static int WriteHeaderFile(const Sapphire::NucleusEngine& engine, const char *outHeaderFileName);

int main()
{
    using namespace Sapphire;

    const std::size_t NUM_PARTICLES = 5;
    NucleusEngine engine{NUM_PARTICLES};

    std::mt19937 rand{0x7c3aaf29u};     // seed was chosen using rolls of physical hexadecimal dice

    const double mean = 0.0;
    const double dev = 1.0;
    std::normal_distribution norm{mean, dev};

    // The first particle, P[0], will be held fixed at the origin.
    // for now, skip it and initialize 1..(N-1) using random positions.
    // Velocities will all start at zero and strong friction will be used
    // to overdamp toward convergence.

    for (std::size_t i = 1; i < NUM_PARTICLES; ++i)
    {
        Particle& p = engine.particle(i);
        p.pos[0] = norm(rand);
        p.pos[1] = norm(rand);
        p.pos[2] = norm(rand);
        p.pos[3] = 0.0f;

        p.vel = PhysicsVector::zero();
    }

    // FIXFIXFIX - Run the simulation until convergence.
    Particle &input = engine.particle(0);
    input.pos = input.vel = PhysicsVector::zero();
    engine.update();

    Print(engine);
    if (WriteHeaderFile(engine, "../src/nucleus_init.hpp")) return 1;
    return 0;
}


static void Print(const Sapphire::NucleusEngine& engine)
{
    using namespace Sapphire;
    const int n = static_cast<int>(engine.numParticles());
    for (int i = 0; i < n; ++i)
    {
        const Particle& p = engine.particle(i);
        printf("i=%u rx=%0.16lg ry=%0.16lg rz=%0.16lg vx=%0.16lg vy=%0.16lg vz=%0.16lg\n",
            static_cast<unsigned>(i),
            p.pos[0], p.pos[1], p.pos[2],
            p.vel[0], p.vel[1], p.vel[2]
        );
    }
}


static int WriteHeaderFile(const Sapphire::NucleusEngine& engine, const char *outHeaderFileName)
{
    using namespace Sapphire;

    const int n = static_cast<int>(engine.numParticles());

    FILE *outfile = fopen(outHeaderFileName, "wt");
    if (outfile == nullptr)
    {
        printf("ERROR(nukesolve): Cannot write to header file [%s]\n", outHeaderFileName);
        return 1;
    }

    fprintf(outfile, "// DO NOT EDIT - THIS CODE IS AUTO-GENERATED BY: %s\n", __FILE__);
    fprintf(outfile, "#pragma once\n");
    fprintf(outfile, "#include \"nucleus_engine.hpp\"\n");
    fprintf(outfile, "namespace Sapphire\n");
    fprintf(outfile, "{\n");
    fprintf(outfile, "    inline int SetMinimumEnergy(NucleusEngine& engine)\n");
    fprintf(outfile, "    {\n");
    fprintf(outfile, "        const int n = static_cast<int>(engine.numParticles());\n");
    fprintf(outfile, "        if (n != %d) return 777;\n", n);
    for (int i = 0; i < n; ++i)
    {
        fprintf(outfile, "\n");
        const Particle& p = engine.particle(i);
        fprintf(outfile, "        Particle& p%d = engine.particle(%d);\n", i, i);
        fprintf(outfile, "        p%d.vel = PhysicsVector::zero();\n", i);
        for (int k = 0; k < 4; ++k)
            fprintf(outfile, "        p%d.pos[%d] = %0.16lg;\n", i, k, p.pos[k]);
    }
    fprintf(outfile, "\n");
    fprintf(outfile, "        return 0;\n");
    fprintf(outfile, "    }\n");
    fprintf(outfile, "}\n");
    fclose(outfile);
    printf("nukesolve: Wrote header file [%s]\n", outHeaderFileName);
    return 0;
}
